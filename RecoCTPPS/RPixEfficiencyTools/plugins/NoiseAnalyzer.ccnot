// -*- C++ -*-
//
// Package:    RecoCTPPS/RPixEfficiencyTools
// Class:      NoiseAnalyzer
//
/**\class InterpotEfficiency_2017 InterpotEfficiency_2017.cc
 RecoCTPPS/RPixEfficiencyTools/plugins/InterpotEfficiency_2017.cc

 Description: [one line class summary]

 Implementation:
                 [Notes on implementation]
*/
//
// Original Author:  Andrea Bellora
//         Created:  Wed, 07 Jul 2019 09:55:05 GMT
//
//

#include <algorithm>
#include <boost/algorithm/string.hpp>
#include <exception>
#include <fstream>
#include <memory>

#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/one/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "DataFormats/CTPPSDetId/interface/CTPPSPixelDetId.h"

#include "DataFormats/CTPPSReco/interface/CTPPSLocalTrackLite.h"
#include "DataFormats/CTPPSReco/interface/CTPPSPixelLocalTrack.h"
#include "DataFormats/CTPPSReco/interface/CTPPSPixelRecHit.h"

#include "DataFormats/CTPPSReco/interface/CTPPSPixelLocalTrackRecoInfo.h"
#include "DataFormats/ProtonReco/interface/ForwardProton.h"
#include "DataFormats/ProtonReco/interface/ForwardProtonFwd.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include <TEfficiency.h>
#include <TF1.h>
#include <TFile.h>
#include <TGraphErrors.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TMath.h>
#include <TObjArray.h>

class InterpotEfficiency_2017
    : public edm::one::EDAnalyzer<edm::one::SharedResources> {
public:
  explicit InterpotEfficiency_2017(const edm::ParameterSet &);
  ~InterpotEfficiency_2017();
  static void fillDescriptions(edm::ConfigurationDescriptions &descriptions);

private:
  virtual void beginJob() override;
  virtual void analyze(const edm::Event &, const edm::EventSetup &) override;
  virtual void endJob() override;
  bool Cut(CTPPSLocalTrackLite track);

  bool debug_ = false;

  // z position of the pots (mm)
  std::map<CTPPSDetId, double> Z = {
      {CTPPSDetId(3, 0, 0, 3), -212550}, // strips, arm0, station0, rp3
      {CTPPSDetId(3, 1, 0, 3), 212550},  // strips, arm1, station0, rp3
      {CTPPSDetId(4, 0, 2, 3), -219550}, // pixels, arm0, station2, rp3
      {CTPPSDetId(4, 1, 2, 3), 219550}}; // pixels, arm1, station2, rp3

  // Data to get
  edm::EDGetTokenT<reco::ForwardProtonCollection> protonsToken_;
  edm::EDGetTokenT<edm::DetSetVector<CTPPSPixelRecHit>> pixelRecHitToken_;

  // Parameter set
  std::string outputFileName_;
  int minNumberOfPlanesForEfficiency_;
  int minNumberOfPlanesForTrack_;
  int maxNumberOfPlanesForTrack_ = 6;
  int minTracksPerEvent;
  int maxTracksPerEvent;

  // Configs
  std::vector<uint32_t> listOfArms_ = {0, 1};
  std::vector<uint32_t> listOfStations_ = {2};
  std::vector<uint32_t> listOfPlanes_ = {0, 1, 2, 3, 4, 5};

  std::vector<CTPPSPixelDetId> detectorIdVector_;
  std::vector<CTPPSPixelDetId> romanPotIdVector_;

  int binGroupingX = 1;
  int binGroupingY = 1;

  int mapXbins_st2 = 200;
  float mapXmin_st2 = 0. * TMath::Cos(18.4 / 180. * TMath::Pi());
  float mapXmax_st2 = 30. * TMath::Cos(18.4 / 180. * TMath::Pi());
  int mapYbins_st2 = 240;
  float mapYmin_st2 = -16.;
  float mapYmax_st2 = 8.;

  int mapXbins_st0 = 200;
  float mapXmin_st0 = 0. * TMath::Cos(18.4 / 180. * TMath::Pi());
  float mapXmax_st0 = 30. * TMath::Cos(18.4 / 180. * TMath::Pi());
  int mapYbins_st0 = 240;
  float mapYmin_st0 = -16.;
  float mapYmax_st0 = 8.;

  int mapXbins = mapXbins_st0;
  float mapXmin = mapXmin_st0;
  float mapXmax = mapXmax_st0;
  int mapYbins = mapYbins_st0;
  float mapYmin = mapYmin_st0;
  float mapYmax = mapYmax_st0;

  double xiBins = 44;
  double xiMin = 0.0;
  double xiMax = 0.22;
  double angleBins = 100;
  double angleMin = -0.03;
  double angleMax = 0.03;

  // output histograms
  std::map<CTPPSPixelDetId, TH1D *> h1RecoInfo_;
  std::map<CTPPSPixelDetId, TH1D *> h1PixelTrackMux_;
  std::map<CTPPSPixelDetId, TH2D *> h2ProtonDistribution_;
  std::map<CTPPSPixelDetId, TH1D *> h1Xi_;
  std::map<CTPPSPixelDetId, TH1D *> h1XProjection_;

  std::map<CTPPSDetId, uint32_t> trackMux_;

  std::vector<double> fiducialXLowVector_;
  std::vector<double> fiducialXHighVector_;
  std::vector<double> fiducialYLowVector_;
  std::vector<double> fiducialYHighVector_;
  std::map<std::pair<int, int>, double> fiducialXLow_;
  std::map<std::pair<int, int>, double> fiducialXHigh_;
  std::map<std::pair<int, int>, double> fiducialYLow_;
  std::map<std::pair<int, int>, double> fiducialYHigh_;
  int recoInfoCut_;
  int maxProtonsInPixelRP_;
};
EfficiencyVsXi_2017::EfficiencyVsXi_2017(const edm::ParameterSet &iConfig) {
  usesResource("TFileService");
  protonsToken_ = consumes<reco::ForwardProtonCollection>(
      edm::InputTag("ctppsProtons", "singleRP"));
  pixelRecHitToken_ = consumes<edm::DetSetVector<CTPPSPixelRecHit>>(
      edm::InputTag("ctppsPixelRecHits", ""));

  efficiencyFileName_ =
      iConfig.getUntrackedParameter<std::string>("efficiencyFileName");
  minNumberOfPlanesForEfficiency_ =
      iConfig.getParameter<int>("minNumberOfPlanesForEfficiency"); // UNUSED!
  minNumberOfPlanesForTrack_ =
      iConfig.getParameter<int>("minNumberOfPlanesForTrack");
  minTracksPerEvent = iConfig.getParameter<int>("minTracksPerEvent"); // UNUSED!
  maxTracksPerEvent = iConfig.getParameter<int>("maxTracksPerEvent"); // UNUSED!
  binGroupingX = iConfig.getUntrackedParameter<int>("binGroupingX");  // UNUSED!
  binGroupingY = iConfig.getUntrackedParameter<int>("binGroupingY");  // UNUSED!
  fiducialXLowVector_ =
      iConfig.getUntrackedParameter<std::vector<double>>("fiducialXLow");
  fiducialXHighVector_ =
      iConfig.getUntrackedParameter<std::vector<double>>("fiducialXHigh");
  fiducialYLowVector_ =
      iConfig.getUntrackedParameter<std::vector<double>>("fiducialYLow");
  fiducialYHighVector_ =
      iConfig.getUntrackedParameter<std::vector<double>>("fiducialYHigh");
  fiducialXLow_ = {
      {std::pair<int, int>(0, 0), fiducialXLowVector_.at(0)},
      {std::pair<int, int>(0, 2), fiducialXLowVector_.at(1)},
      {std::pair<int, int>(1, 0), fiducialXLowVector_.at(2)},
      {std::pair<int, int>(1, 2), fiducialXLowVector_.at(3)},
  };
  fiducialXHigh_ = {
      {std::pair<int, int>(0, 0), fiducialXHighVector_.at(0)},
      {std::pair<int, int>(0, 2), fiducialXHighVector_.at(1)},
      {std::pair<int, int>(1, 0), fiducialXHighVector_.at(2)},
      {std::pair<int, int>(1, 2), fiducialXHighVector_.at(3)},
  };
  fiducialYLow_ = {
      {std::pair<int, int>(0, 0), fiducialYLowVector_.at(0)},
      {std::pair<int, int>(0, 2), fiducialYLowVector_.at(1)},
      {std::pair<int, int>(1, 0), fiducialYLowVector_.at(2)},
      {std::pair<int, int>(1, 2), fiducialYLowVector_.at(3)},
  };
  fiducialYHigh_ = {
      {std::pair<int, int>(0, 0), fiducialYHighVector_.at(0)},
      {std::pair<int, int>(0, 2), fiducialYHighVector_.at(1)},
      {std::pair<int, int>(1, 0), fiducialYHighVector_.at(2)},
      {std::pair<int, int>(1, 2), fiducialYHighVector_.at(3)},
  };
  recoInfoCut_ = iConfig.getUntrackedParameter<int>("recoInfo");
  maxProtonsInPixelRP_ =
      iConfig.getUntrackedParameter<int>("maxProtonsInPixelRP");
}

InterpotEfficiency_2017::~InterpotEfficiency_2017() {
  for (auto &rpId : romanPotIdVector_) {
    delete h1RecoInfo_[rpId];
    delete h1PixelTrackMux_[rpId];
    delete h2ProtonDistribution_[rpId];
    delete h1Xi_[rpId];
    delete h1XProjection_[rpId];
  }
}

void EfficiencyVsXi_2017::fillDescriptions(
    edm::ConfigurationDescriptions &descriptions) {
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

void EfficiencyVsXi_2017::beginJob() {}

void InterpotEfficiency_2017::endJob() {
  TFile *outputFile_ = new TFile(outputFileName_.data(), "RECREATE");
  for (auto &rpId : romanPotIdVector_) {
    uint32_t arm = rpId.arm();
    uint32_t station = rpId.station();
    std::string rpDirName = Form("Arm%i_st%i_rp3", arm, station);
    outputFile_->mkdir(rpDirName.data());
    outputFile_->cd(rpDirName.data());

    if (h1InterPotEfficiencyVsXi_.find(rpId) !=
        h1InterPotEfficiencyVsXi_.end()) {
      h1RecoInfo_[rpId]->Write();
      h1PixelTrackMux_[rpId]->Write();
      h2ProtonDistribution_[rpId]->Write();
      h1Xi_[rpId]->Write();
      h1XProjection_[rpId]->Write();
    }
  }
  outputFile_->Close();
  delete outputFile_;
}

bool NoiseAnalyzer::Cut(CTPPSLocalTrackLite track) {
  CTPPSDetId detId = CTPPSDetId(track.getRPId());
  uint32_t arm = detId.arm();
  uint32_t station = detId.station();
  uint32_t ndf = 2 * track.getNumberOfPointsUsedForFit() - 4;
  double x = track.getX();
  double y = track.getY();

  double maxTx = 0.02;
  double maxTy = 0.02;
  double maxChi2 = TMath::ChisquareQuantile(0.95, ndf);
  if (station == 2) {

    if (TMath::Abs(track.getTx()) > maxTx ||
        TMath::Abs(track.getTy()) > maxTy ||
        track.getChiSquaredOverNDF() * ndf > maxChi2 ||
        track.getNumberOfPointsUsedForFit() < minNumberOfPlanesForTrack_ ||
        track.getNumberOfPointsUsedForFit() > maxNumberOfPlanesForTrack_ ||
        y > fiducialYHigh_[std::pair<int, int>(arm, station)] ||
        y < fiducialYLow_[std::pair<int, int>(arm, station)] ||
        x < fiducialXLow_[std::pair<int, int>(arm, station)] ||
        x > fiducialXHigh_[std::pair<int, int>(arm, station)])
      return true;
    else {
      if (recoInfoCut_ != -1 &&
          (int)track.getPixelTrackRecoInfo() != recoInfoCut_)
        return true;
      else
        return false;
    }
  } else {
    if (station == 0) {
      // if (TMath::Abs(track.getTx()) > maxTx ||
      //     TMath::Abs(track.getTy()) > maxTy ||
      //     track.getChiSquaredOverNDF() * ndf > maxChi2)
      // return true;
      // else
      return false;
    } else
      throw "Station is neither 0 or 2!!!";
  }
}

// define this as a plug-in
// DEFINE_FWK_MODULE(NoiseAnalyzer);